Index: docker.io/daemon/logger/gcplogs/gcplogging.go
===================================================================
--- docker.io.orig/daemon/logger/gcplogs/gcplogging.go
+++ docker.io/daemon/logger/gcplogs/gcplogging.go
@@ -51,7 +51,7 @@ func init() {
 }
 
 type gcplogs struct {
-	client    *logging.Client
+	logger    *logging.Logger
 	instance  *instanceInfo
 	container *containerInfo
 }
@@ -114,17 +114,19 @@ func New(ctx logger.Context) (logger.Log
 		return nil, fmt.Errorf("No project was specified and couldn't read project from the meatadata server. Please specify a project")
 	}
 
-	c, err := logging.NewClient(context.Background(), project, "gcplogs-docker-driver")
+	c, err := logging.NewClient(context.Background(), project)
 	if err != nil {
 		return nil, err
 	}
 
-	if err := c.Ping(); err != nil {
+	lg := c.Logger("gcplogs-docker-driver")
+
+	if err := c.Ping(context.Background()); err != nil {
 		return nil, fmt.Errorf("unable to connect or authenticate with Google Cloud Logging: %v", err)
 	}
 
 	l := &gcplogs{
-		client: c,
+		logger: lg,
 		container: &containerInfo{
 			Name:      ctx.ContainerName,
 			ID:        ctx.ContainerID,
@@ -157,11 +159,14 @@ func New(ctx logger.Context) (logger.Log
 	// overflow func is called. We want to surface the error to the user
 	// without overly spamming /var/log/docker.log so we log the first time
 	// we overflow and every 1000th time after.
-	c.Overflow = func(_ *logging.Client, _ logging.Entry) error {
-		if i := atomic.AddUint64(&droppedLogs, 1); i%1000 == 1 {
-			logrus.Errorf("gcplogs driver has dropped %v logs", i)
-		}
-		return nil
+	c.OnError = func(err error) {
+               if err == logging.ErrOverflow {
+                       if i := atomic.AddUint64(&droppedLogs, 1); i%1000 == 1 {
+                               logrus.Errorf("gcplogs driver has dropped %v logs", i)
+                       }
+               } else {
+                       logrus.Error(err)
+	       }
 	}
 
 	return l, nil
@@ -181,18 +186,20 @@ func ValidateLogOpts(cfg map[string]stri
 }
 
 func (l *gcplogs) Log(m *logger.Message) error {
-	return l.client.Log(logging.Entry{
-		Time: m.Timestamp,
+	l.logger.Log(logging.Entry{
+		Timestamp: m.Timestamp,
 		Payload: &dockerLogEntry{
 			Instance:  l.instance,
 			Container: l.container,
 			Data:      string(m.Line),
 		},
 	})
+	return nil
 }
 
 func (l *gcplogs) Close() error {
-	return l.client.Flush()
+	l.logger.Flush()
+	return nil
 }
 
 func (l *gcplogs) Name() string {

Index: docker.io/libcontainerd/remote_linux.go
===================================================================
--- docker.io.orig/libcontainerd/remote_linux.go
+++ docker.io/libcontainerd/remote_linux.go
@@ -23,12 +23,14 @@ import (
 	"golang.org/x/net/context"
 	"google.golang.org/grpc"
 	"google.golang.org/grpc/grpclog"
+	"google.golang.org/grpc/health/grpc_health_v1"
 	"google.golang.org/grpc/transport"
 )
 
 const (
 	maxConnectionRetryCount   = 3
 	connectionRetryDelay      = 3 * time.Second
+	containerdHealthCheckTimeout = 3 * time.Second
 	containerdShutdownTimeout = 15 * time.Second
 	containerdBinary          = "containerd"
 	containerdPidFilename     = "docker-containerd.pid"
@@ -50,6 +52,7 @@ type remote struct {
 	eventTsPath   string
 	pastEvents    map[string]*containerd.Event
 	runtimeArgs   []string
+	daemonWaitCh  chan struct{}
 }
 
 // New creates a fresh instance of libcontainerd remote.
@@ -111,36 +114,41 @@ func New(stateDir string, options ...Rem
 
 func (r *remote) handleConnectionChange() {
 	var transientFailureCount = 0
-	state := grpc.Idle
+
+	ticker := time.NewTicker(500 * time.Millisecond)
+	defer ticker.Stop()
+	healthClient := grpc_health_v1.NewHealthClient(r.rpcConn)
+
 	for {
-		s, err := r.rpcConn.WaitForStateChange(context.Background(), state)
-		if err != nil {
-			break
+		<-ticker.C
+		ctx, cancel := context.WithTimeout(context.Background(), containerdHealthCheckTimeout)
+		_, err := healthClient.Check(ctx, &grpc_health_v1.HealthCheckRequest{})
+		cancel()
+		if err == nil {
+			continue
 		}
-		state = s
-		logrus.Debugf("containerd connection state change: %v", s)
+
+		logrus.Debugf("libcontainerd: containerd health check returned error: %v", err)
 
 		if r.daemonPid != -1 {
-			switch state {
-			case grpc.TransientFailure:
-				// Reset state to be notified of next failure
-				transientFailureCount++
-				if transientFailureCount >= maxConnectionRetryCount {
-					transientFailureCount = 0
-					if utils.IsProcessAlive(r.daemonPid) {
-						utils.KillProcess(r.daemonPid)
-					}
-					if err := r.runContainerdDaemon(); err != nil { //FIXME: Handle error
-						logrus.Errorf("error restarting containerd: %v", err)
-					}
-				} else {
-					state = grpc.Idle
-					time.Sleep(connectionRetryDelay)
-				}
-			case grpc.Shutdown:
+			if strings.Contains(err.Error(), "is closing") {
 				// Well, we asked for it to stop, just return
 				return
 			}
+			// all other errors are transient
+			// Reset state to be notified of next failure
+			transientFailureCount++
+			if transientFailureCount >= maxConnectionRetryCount {
+				transientFailureCount = 0
+				if utils.IsProcessAlive(r.daemonPid) {
+					utils.KillProcess(r.daemonPid)
+				}
+				<-r.daemonWaitCh
+				if err := r.runContainerdDaemon(); err != nil { //FIXME: Handle error
+					logrus.Errorf("libcontainerd: error restarting containerd: %v", err)
+				}
+				continue
+			}
 		}
 	}
 }
@@ -383,7 +391,11 @@ func (r *remote) runContainerdDaemon() e
 		return err
 	}
 
-	go cmd.Wait() // Reap our child when needed
+	r.daemonWaitCh = make(chan struct{})
+	go func() {
+		cmd.Wait()
+		close(r.daemonWaitCh)
+	}() // Reap our child when needed
 	r.daemonPid = cmd.Process.Pid
 	return nil
 }
